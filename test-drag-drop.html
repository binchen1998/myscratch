<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精灵拖放功能测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            display: block;
            margin: 20px auto;
            cursor: default;
        }
        .test-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #0056b3;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .sprite-info {
            display: flex;
            gap: 20px;
            margin: 10px 0;
        }
        .sprite-card {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
    </style>
</head>
<body>
    <h1>精灵拖放功能测试</h1>
    
    <div class="test-section">
        <h2>功能说明</h2>
        <p>这个测试页面用于验证精灵拖放功能的正确性。修复了精灵点击检测不准确的问题。</p>
        
        <div class="status info">
            <strong>修复内容：</strong>
            <ul>
                <li>修复了精灵点击检测使用固定尺寸的问题</li>
                <li>现在使用精灵图片的实际尺寸进行碰撞检测</li>
                <li>添加了鼠标悬停检测，显示正确的光标</li>
                <li>改进了拖放体验</li>
            </ul>
        </div>
    </div>
    
    <div class="test-section">
        <h2>测试Canvas</h2>
        <canvas id="testCanvas" width="480" height="360" class="test-canvas"></canvas>
        
        <div class="sprite-info">
            <div class="sprite-card">
                <strong>精灵1</strong><br>
                位置: <span id="sprite1Pos">(240, 180)</span><br>
                尺寸: <span id="sprite1Size">40x40</span>
            </div>
            <div class="sprite-card">
                <strong>精灵2</strong><br>
                位置: <span id="sprite2Pos">(100, 100)</span><br>
                尺寸: <span id="sprite2Size">60x60</span>
            </div>
        </div>
        
        <button class="test-button" onclick="addTestSprites()">添加测试精灵</button>
        <button class="test-button" onclick="clearCanvas()">清空Canvas</button>
        
        <div id="status" class="status" style="display: none;"></div>
    </div>
    
    <div class="test-section">
        <h2>测试步骤</h2>
        <ol>
            <li>点击"添加测试精灵"按钮添加测试精灵</li>
            <li>尝试点击和拖拽精灵</li>
            <li>观察鼠标光标变化</li>
            <li>检查精灵位置更新</li>
        </ol>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        
        let sprites = [];
        let isDragging = false;
        let draggedSprite = null;
        let dragOffset = { x: 0, y: 0 };
        
        // 创建测试精灵
        function createTestSprite(name, x, y, size) {
            // 创建一个简单的彩色矩形作为精灵
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 绘制彩色矩形
            tempCtx.fillStyle = name === '精灵1' ? '#ff6b6b' : '#4ecdc4';
            tempCtx.fillRect(0, 0, size, size);
            
            // 添加边框
            tempCtx.strokeStyle = '#333';
            tempCtx.lineWidth = 2;
            tempCtx.strokeRect(0, 0, size, size);
            
            // 添加文字
            tempCtx.fillStyle = '#fff';
            tempCtx.font = '12px Arial';
            tempCtx.textAlign = 'center';
            tempCtx.fillText(name, size/2, size/2 + 4);
            
            return {
                id: name,
                name: name,
                x: x,
                y: y,
                image: tempCanvas,
                scale: 1.0,
                visible: true
            };
        }
        
        // 添加测试精灵
        function addTestSprites() {
            sprites = [
                createTestSprite('精灵1', 240, 180, 40),
                createTestSprite('精灵2', 100, 100, 60)
            ];
            
            updateSpriteInfo();
            drawCanvas();
            
            showStatus('测试精灵已添加，可以尝试点击和拖拽', 'success');
        }
        
        // 清空Canvas
        function clearCanvas() {
            sprites = [];
            drawCanvas();
            showStatus('Canvas已清空', 'info');
        }
        
        // 绘制Canvas
        function drawCanvas() {
            // 清空Canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            drawGrid();
            
            // 绘制精灵
            sprites.forEach(sprite => {
                if (sprite.visible) {
                    drawSprite(sprite);
                }
            });
        }
        
        // 绘制网格
        function drawGrid() {
            const gridSize = 20;
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // 绘制垂直线
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 绘制水平线
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // 绘制中心线
            ctx.strokeStyle = '#4c97ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(240, 0);
            ctx.lineTo(240, canvas.height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 180);
            ctx.lineTo(canvas.width, 180);
            ctx.stroke();
        }
        
        // 绘制精灵
        function drawSprite(sprite) {
            ctx.save();
            ctx.translate(sprite.x, sprite.y);
            ctx.scale(sprite.scale, sprite.scale);
            
            const imgWidth = sprite.image.width;
            const imgHeight = sprite.image.height;
            
            ctx.drawImage(sprite.image, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
            ctx.restore();
        }
        
        // 获取精灵在指定位置
        function getSpriteAtPosition(x, y) {
            for (let i = sprites.length - 1; i >= 0; i--) {
                const sprite = sprites[i];
                if (!sprite.visible) continue;
                
                const imgWidth = sprite.image.width;
                const imgHeight = sprite.image.height;
                const actualWidth = imgWidth * sprite.scale;
                const actualHeight = imgHeight * sprite.scale;
                const halfWidth = actualWidth / 2;
                const halfHeight = actualHeight / 2;
                
                if (x >= sprite.x - halfWidth && x <= sprite.x + halfWidth &&
                    y >= sprite.y - halfHeight && y <= sprite.y + halfHeight) {
                    return sprite;
                }
            }
            return null;
        }
        
        // 更新精灵信息显示
        function updateSpriteInfo() {
            if (sprites.length >= 1) {
                document.getElementById('sprite1Pos').textContent = `(${Math.round(sprites[0].x)}, ${Math.round(sprites[0].y)})`;
                document.getElementById('sprite1Size').textContent = `${sprites[0].image.width}x${sprites[0].image.height}`;
            }
            if (sprites.length >= 2) {
                document.getElementById('sprite2Pos').textContent = `(${Math.round(sprites[1].x)}, ${Math.round(sprites[1].y)})`;
                document.getElementById('sprite2Size').textContent = `${sprites[1].image.width}x${sprites[1].image.height}`;
            }
        }
        
        // 显示状态
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.textContent = message;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
        
        // 鼠标事件处理
        canvas.addEventListener('mousedown', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const sprite = getSpriteAtPosition(x, y);
            if (sprite) {
                isDragging = true;
                draggedSprite = sprite;
                dragOffset.x = x - sprite.x;
                dragOffset.y = y - sprite.y;
                canvas.style.cursor = 'grabbing';
                
                showStatus(`开始拖拽 ${sprite.name}`, 'success');
            }
        });
        
        canvas.addEventListener('mousemove', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // 处理拖拽
            if (isDragging && draggedSprite) {
                const newX = x - dragOffset.x;
                const newY = y - dragOffset.y;
                
                // 限制在canvas边界内
                const halfWidth = draggedSprite.image.width * draggedSprite.scale / 2;
                const halfHeight = draggedSprite.image.height * draggedSprite.scale / 2;
                
                draggedSprite.x = Math.max(halfWidth, Math.min(canvas.width - halfWidth, newX));
                draggedSprite.y = Math.max(halfHeight, Math.min(canvas.height - halfHeight, newY));
                
                drawCanvas();
                updateSpriteInfo();
            } else {
                // 鼠标悬停检测
                const sprite = getSpriteAtPosition(x, y);
                if (sprite) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        });
        
        canvas.addEventListener('mouseup', function(event) {
            if (isDragging) {
                isDragging = false;
                draggedSprite = null;
                canvas.style.cursor = 'default';
                showStatus('拖拽结束', 'info');
            }
        });
        
        canvas.addEventListener('mouseleave', function(event) {
            if (isDragging) {
                isDragging = false;
                draggedSprite = null;
                canvas.style.cursor = 'default';
            }
        });
        
        // 初始化
        drawCanvas();
    </script>
</body>
</html> 